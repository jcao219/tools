open Core.Std
open Cli_util
open Process_util

type options = Cli_config.email_command_options

(** [bcc_of_file fname] read the list of email addresses stored in the file [fname]. *)
let bcc_of_file (fname : string) : StringSet.t =
  begin match Sys.file_exists fname with
    | `No | `Unknown ->
      StringSet.empty
    | `Yes           ->
      let lines = In_channel.with_file fname ~f:In_channel.input_lines in
      StringSet.of_list lines
  end

(** [format_bcc bccs] convert a list of email addresses into
    command-line option format for the [mutt] utility. *)
let format_bcc (bccs : StringSet.t) : string =
  let bcc_list = StringSet.to_list bccs in
  Format.sprintf "-b '%s'" (String.concat ~sep:"' -b '" bcc_list)

(** [is_valid_netid str] True if the string [str] is lowercase letters followed by
    numbers. *)
let is_valid_netid (str : string) : bool =
  let pattern = Str.regexp "^[a-z]+[0-9]+$" in
  Str.string_match pattern str 0

(** [is_email s] check if the string [s] looks like an email address. *)
let is_valid_email (str : string) : bool =
  (* minimal email address would look like 'a@a.a' or '@.aaa' *)
  String.contains str '@' && String.contains str '.' && (4 < String.length str)

(** [add_email_domain users] Append an email domain to a list of
    half-complete addresses. Like, 'blg59' would map to 'blg59@cornell.edu' *)
let add_email_domain (users : string list) : string list =
  List.map ~f:(fun x -> x ^ "@cornell.edu") users

(** [get_recipients fname] generate an email address from a message file.
    Message files should look like '<netid>.txt' or 'group_of_<netid>_<netid>.txt'. *)
let get_recipients (msg_file : string) : string list =
  add_email_domain (List.filter ~f:is_valid_netid (String.split ~on:'_' (strip_suffix msg_file)))

(** [parse_bccs addrs] parse a set of email addresses from a list of strings.
    If a string doesn't look like an email address, try reading it as a file. *)
let parse_bccs (addrs : string list) : StringSet.t =
  List.fold addrs
    ~f:(fun acc x ->
        if is_valid_email x
        then StringSet.add acc x
        else StringSet.union acc (bcc_of_file x))
    ~init:StringSet.empty

(** [print_results npass nfail] pretty-print details on the number
    of emails sent. *)
let print_results (num_success:int) (num_failure:int) =
  let total = num_success + num_failure in
  Format.printf
    "Emailing complete! Attempted to send %d messages.\n\
     - %d sent successfully.\n\
     - %d failed to send.\n"
    total num_success num_failure

(** [send_email_for_file ?v o f] Send the email message in file [f]
    to the recipient(s) determined by [f].
    The options [o] change behavior a little. See the command readme. *)
let send_email_for_file ?(verbose=false) (opts : options) (msg_file : string) : bool =
  begin match get_recipients msg_file with
    | []    ->
       let () = Format.printf "[email] Skipping invalid message file '%s'. The file name should be '<netid>.txt' or 'group_of_<netid>_<netid>.txt'.\n" msg_file in
       false
    | rcpts ->
       let f_cmd = fun recipient -> Format.sprintf "mutt -s '%s' %s '%s' < %s/%s"
                     opts.subject
                     (format_bcc opts.admins)
                     recipient
                     opts.input_directory
                     msg_file
       in
       let all_pass =
         List.fold_left rcpts ~init:true
           ~f:(fun acc recipient ->
                 let cmd = f_cmd recipient in
                 let () = if verbose then Format.printf "[cs3110 email] Executing '%s'\n%!" cmd in
                 (* Print a message if the command failed *)
                 acc && ((Sys.command cmd) = 0 || (Format.printf "[email] Failed to send message to: '%s'\n" recipient; false)))
       in
       all_pass
  end

(** [email ?v o ms] Send all messages in the collection [ms].
    See the command readme for available options [o]. *)
let email ?(verbose=false) (opts : options) (message_files : string array) : unit =
  let num_success, num_failure =
    Array.fold message_files
      ~init:(0,0)
      ~f:(fun (num_success,num_failure) (msg_file : string) ->
           if send_email_for_file ~verbose:verbose opts msg_file
           then num_success+1 , num_failure
           else num_success   , num_failure+1)
  in
  print_results num_success num_failure

let command =
  Command.basic
    ~summary:"Send emails generated by [cs3110 smoke]"
    ~readme:(fun () -> String.concat ~sep:"\n" [
       "Collects the email messages generated by [cs3110 smoke] and sends them";
       "to students. Course administrators are included as bcc's in the emails.";
       "Prints a warning if a message fails to send and records the total";
       "number of messages sent."
     ])
    Command.Spec.(
      empty
      +> flag ~aliases:["-v"] "-verbose" no_arg            ~doc:" Print debugging information."
      +> flag ~aliases:["-b"] "-bcc"     (listed string)   ~doc:"ADDR Include email address ADDR as a bcc on all emails."
      +> flag ~aliases:["-s"] "-subject" (optional string) ~doc:"SUBJECT Use string SUBJECT instead of the default subject."
      +> flag ~aliases:["-d"] "-dir"     (optional string) ~doc:"DIR Search directory DIR for emails instead of the default."
    )
    (fun v bccs subject dir () ->
      let cfg  = Cli_config.init () in
      let opts = ({
        admins          = begin match bccs with
                             | []   -> cfg.email.admins
                             | _::_ -> parse_bccs bccs
                           end;
        subject         = Option.value subject  ~default:cfg.email.subject;
        input_directory = Option.value dir      ~default:cfg.email.input_directory;
      } : options) in
      let ()   = assert_file_exists opts.input_directory in
      let ()   = assert_installed "mutt" in
      email ~verbose:v opts (Sys.readdir opts.input_directory)
    )
